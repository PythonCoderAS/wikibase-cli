#!/usr/bin/env node
const program = require('../lib/program')

program
.option('-p, --props <props>', 'request only certain properties (info, sitelinks, aliases, labels, descriptions, claims, datatype)')
.option('-r, --revision <id>', 'request a specific revision')
.option('-f, --format <format>', 'Default: json. Alternatives: js')
.option('-m, --create-mode', 'optimize for creating an entity from a previously existing one, namely dropping ids from the existing entity used as template')
.process('generate-template')

const { createMode = false } = program

const parseId = require('../lib/tolerant_id_parser')
const ids = program.args.map(parseId)
require('../lib/exit_on_missing').instance(program.instance)
const { isEntityId, getEntityRevision, getManyEntities, simplify } = require('../lib/wbk')(program)
const { pick } = require('lodash')
const parseProps = require('../lib/parse_props')
const dropNonSelectedSubprops = require('../lib/drop_non_selected_subprops')
const minimizeClaims = require('../lib/minimize_claims')
const { revision, format } = program
const getEntitiesByBatches = require('../lib/get_entities_by_batches')
const stringifyAsJsFunction = require('../lib/stringify_as_js_function')

const requestedPropsAndSubProps = parseProps(program.props)
const requestedProps = Object.keys(requestedPropsAndSubProps)

const requiredKeys = [ 'id', 'type', 'datatype', 'labels', 'descriptions', 'aliases', 'claims', 'sitelinks' ]

const simplifyOptions = {
  keepIds: !createMode,
  keepQualifiers: true,
  keepReferences: true,
  keepRichValues: true,
  keepNonTruthy: true,
  keepSnaktypes: true,
  // No need to keep the hashes as every edited claim (identified with a GUID)
  // will have it's qualifiers and references fully overriden
  keepHashes: false
}

let propsToPick
if (revision && requestedProps.length > 0) propsToPick = [ 'id' ].concat(requestedProps)
else propsToPick = requiredKeys

const FormatEntity = batchMode => entity => {
  entity = simplify.entity(entity, simplifyOptions)
  if (createMode) delete entity.id
  entity = pick(entity, propsToPick)
  dropNonSelectedSubprops(entity, requestedPropsAndSubProps)
  if (!batchMode) minimizeClaims(entity.claims)
  return entity
}

const outputTemplates = batchMode => {
  const formatEntity = FormatEntity(batchMode)
  return async entities => {
    entities = entities.map(formatEntity)
    if (format === 'js') {
      const jsFile = await stringifyAsJsFunction(entities[0], program.lang)
      console.log(jsFile)
    } else {
      const newLines = entities.map(entity => JSON.stringify(entity)).join('\n')
      process.stdout.write(newLines + '\n')
    }
  }
}

const handleIds = async ids => {
  ids.forEach(id => {
    if (!isEntityId(id)) throw new Error(`invalid entity id: ${id}`)
  })

  const batchMode = ids.length > 1

  if (batchMode && format === 'js') {
    throw new Error("js format can't be used when several entities are requested")
  }

  let urls
  if (revision) {
    if (ids.length !== 1) throw new Error(`requesting a revision for several entities isn't supported: ${ids}`)
    urls = [ getEntityRevision(ids[0], revision) ]
  } else {
    urls = getManyEntities({ ids, props: requestedProps })
  }

  return getEntitiesByBatches({
    urls,
    onResponse: outputTemplates(batchMode)
  })
}

if (ids.length > 0) {
  handleIds(ids)
} else {
  require('../lib/read_ids_from_stdin')(handleIds)
}
